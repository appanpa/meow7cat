<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智慧型車行軌跡視覺化工具</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Font Awesome (提供圖示) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- 引入 Leaflet.js (地圖函式庫) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- 引入 SheetJS (xlsx/xls 檔案解析) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- 引入 Leaflet Polyline Decorator (軌跡箭頭) -->
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>
    <!-- 引入 html2canvas (畫面擷取) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #111827;
            color: #f9fafb;
        }
        #map {
            height: 100%;
            width: 100%;
            border-radius: 0.5rem;
        }
        .card {
            background-color: #1f2937;
            border: 1px solid #374151;
            border-radius: 0.5rem;
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            color: #ffffff;
            background-color: #2563eb;
            border: 1px solid #1d4ed8;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            background-color: #1d4ed8;
        }
        .btn:disabled {
            background-color: #374151;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #7c3aed;
            border-color: #6d28d9;
        }
        .btn-secondary:hover {
            background-color: #6d28d9;
        }
        .btn-success {
            background-color: #16a34a;
            border-color: #15803d;
        }
        .btn-success:hover {
            background-color: #15803d;
        }
        .btn-info {
            background-color: #0891b2; /* cyan-600 */
            border-color: #0e7490;
        }
        .btn-info:hover {
            background-color: #0e7490;
        }
        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 2rem 1.25rem;
            border: 2px dashed #374151;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #9ca3af;
        }
        .file-input-label:hover {
            border-color: #2563eb;
            background-color: #111827;
            color: #ffffff;
        }
        input, select, textarea {
            background-color: #111827;
            border: 1px solid #374151;
            color: #f9fafb;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.5);
        }
        .loader {
            border: 4px solid rgba(249, 250, 251, 0.2);
            border-top: 4px solid #f9fafb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .number-marker {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 12px;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .layer-control-container, .dashboard-list {
            max-height: 150px;
            overflow-y: auto;
        }
        .layer-control-item, .dashboard-list-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-radius: 0.25rem;
        }
        .layer-control-item:hover, .dashboard-list-item:hover {
            background-color: #374151;
        }
        .layer-control-item input {
            margin-right: 0.75rem;
            width: 1rem;
            height: 1rem;
        }
        .color-box {
            width: 1rem;
            height: 1rem;
            margin-right: 0.75rem;
            border: 1px solid #f9fafb;
        }
        .data-table-container {
            max-height: 400px;
            overflow: auto;
            border: 1px solid #374151;
            border-radius: 0.25rem;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }
        .data-table th, .data-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #374151;
            white-space: nowrap;
        }
        .data-table th {
            background-color: #111827;
            position: sticky;
            top: 0;
        }
        .data-table tbody tr:hover {
            background-color: #374151;
        }
        .clickable-coord {
            color: #60a5fa; /* Light blue */
            cursor: pointer;
            text-decoration: underline;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-screen-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white">智慧型車行軌跡視覺化工具</h1>
            <p class="text-gray-400 mt-2">結合路線規劃與 AI 分析，不僅呈現軌跡，更能洞察先機。</p>
        </header>

        <!-- 主要格線：控制項與地圖 -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <div id="left-controls" class="lg:col-span-4 space-y-6">
                 <div class="card p-6">
                    <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-upload mr-2"></i>步驟 1: 上傳檔案</h2>
                    <label for="file-input" class="file-input-label">
                        <i class="fas fa-file-csv fa-2x"></i>
                        <span id="file-name">點擊此處選擇 CSV/XLSX/XLS 檔案</span>
                    </label>
                    <input type="file" id="file-input" accept=".csv, .xlsx, .xls" class="hidden">
                </div>

                <div id="column-mapping" class="card p-6 hidden">
                    <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-columns mr-2"></i>步驟 2: 對應欄位</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="lat-col" class="block mb-1 text-sm font-medium">緯度 (Latitude)</label>
                            <select id="lat-col" class="w-full"></select>
                        </div>
                        <div>
                            <label for="lon-col" class="block mb-1 text-sm font-medium">經度 (Longitude)</label>
                            <select id="lon-col" class="w-full"></select>
                        </div>
                        <div>
                            <label for="time-col" class="block mb-1 text-sm font-medium">時間 (Time)</label>
                            <select id="time-col" class="w-full"></select>
                        </div>
                    </div>
                </div>

                <div class="card p-6">
                     <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-cogs mr-2"></i>步驟 3: 產生軌跡</h2>
                    <button id="process-btn" class="btn w-full" disabled>
                        <i class="fas fa-play-circle mr-2"></i>
                        <span>繪製軌跡</span>
                    </button>
                </div>
            </div>

            <div class="lg:col-span-8">
                <!-- 【修改處】移除地圖卡片的內邊距 p-2 -->
                <div id="map-card" class="card">
                    <div id="map"></div>
                </div>
            </div>
        </div>

        <!-- 中層工具列區塊 -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 mt-8">
            <!-- 左側: 偵查儀表板 (佔 3/4) -->
            <div id="dashboard-card" class="lg:col-span-9 card p-6 hidden">
                <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-tachometer-alt mr-2"></i>偵查儀表板</h2>
                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold text-gray-300 mb-2">最常經過點位 (Hot Zone)</h3>
                        <div id="hot-zone-display" class="dashboard-list space-y-1"></div>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-300 mb-2">每日起始點 (Daily Start)</h3>
                        <div id="daily-start-display" class="dashboard-list space-y-1"></div>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-300 mb-2">每日結束點 (Daily End)</h3>
                        <div id="daily-end-display" class="dashboard-list space-y-1"></div>
                    </div>
                </div>
            </div>

            <!-- 右側: 圖層控制與工具 (佔 1/4) -->
            <div class="lg:col-span-3 space-y-8">
                <div id="layer-control-card" class="card p-6 hidden">
                    <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-layer-group mr-2"></i>軌跡圖層控制</h2>
                    <button id="toggle-all-layers-btn" class="btn w-full mb-4">顯示/隱藏所有軌跡</button>
                    <div id="date-checkboxes" class="layer-control-container space-y-2"></div>
                </div>

                <div id="actions-card" class="card p-6 hidden">
                     <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-route mr-2"></i>軌跡工具</h2>
                     <div class="space-y-3">
                         <button id="route-btn" class="btn btn-success w-full"><i class="fab fa-google mr-2"></i>預測行車路線</button>
                         <button id="recenter-map-btn" class="btn btn-secondary w-full"><i class="fas fa-crosshairs mr-2"></i>將軌跡置中</button>
                         <button id="download-map-btn" class="btn btn-info w-full"><i class="fas fa-camera mr-2"></i>下載軌跡圖檔</button>
                     </div>
                </div>
            </div>
        </div>
        
        <!-- 底層分析與資料區塊 -->
        <div class="space-y-8 mt-8">
            <div id="ai-analysis-card" class="card p-6 hidden">
                 <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-brain mr-2"></i>✨ 軌跡智慧分析 (選用)</h2>
                  <p class="text-gray-400 text-sm mb-3">AI 功能將優先使用內建金鑰。若在 Google Site 上遇到權限問題 (錯誤 401/403)，請在此提供您自己的 Google AI API 金鑰。您可以點擊 <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">這裡</a> 免費取得。</p>
                 <div class="flex items-center gap-2 mb-3">
                     <input type="password" id="api-key-input" placeholder="貼上您的 API 金鑰" class="w-full">
                     <button id="save-api-key-btn" class="btn"><i class="fas fa-save"></i></button>
                 </div>
                 <div class="space-y-3">
                     <label for="custom-prompt-input" class="block text-sm font-medium">請輸入您的分析指令 (Prompt)</label>
                     <textarea id="custom-prompt-input" rows="3" class="w-full" placeholder="例如：請找出所有停留超過10分鐘的地點。"></textarea>
                     <button id="ai-submit-btn" class="btn btn-secondary w-full"><i class="fas fa-paper-plane mr-2"></i>送出分析</button>
                     <textarea id="ai-output" rows="8" class="w-full mt-3" placeholder="AI 分析結果將顯示於此..." readonly></textarea>
                 </div>
            </div>
            
            <div id="data-display-card" class="card p-6 hidden">
                <h2 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-table mr-2"></i>原始資料預覽</h2>
                <p class="text-gray-400 text-sm mb-3">此處顯示您上傳檔案的前 50 筆資料以供核對。</p>
                <div id="data-table-container" class="data-table-container"></div>
            </div>
        </div>

        <div id="status" class="text-center text-gray-400 mt-8"></div>
    </div>

    <script>
        // --- DOM 元素 ---
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const fileInput = document.getElementById('file-input');
        const fileNameSpan = document.getElementById('file-name');
        const dataDisplayCard = document.getElementById('data-display-card');
        const dataTableContainer = document.getElementById('data-table-container');
        const columnMappingDiv = document.getElementById('column-mapping');
        const latSelect = document.getElementById('lat-col');
        const lonSelect = document.getElementById('lon-col');
        const timeSelect = document.getElementById('time-col');
        const processBtn = document.getElementById('process-btn');
        const statusDiv = document.getElementById('status');
        const dashboardCard = document.getElementById('dashboard-card');
        const hotZoneDisplay = document.getElementById('hot-zone-display');
        const dailyStartDisplay = document.getElementById('daily-start-display');
        const dailyEndDisplay = document.getElementById('daily-end-display');
        const actionsCard = document.getElementById('actions-card');
        const routeBtn = document.getElementById('route-btn');
        const downloadMapBtn = document.getElementById('download-map-btn');
        const recenterMapBtn = document.getElementById('recenter-map-btn');
        const aiAnalysisCard = document.getElementById('ai-analysis-card');
        const customPromptInput = document.getElementById('custom-prompt-input');
        const aiSubmitBtn = document.getElementById('ai-submit-btn');
        const aiOutput = document.getElementById('ai-output');
        const layerControlCard = document.getElementById('layer-control-card');
        const dateCheckboxesContainer = document.getElementById('date-checkboxes');
        const toggleAllLayersBtn = document.getElementById('toggle-all-layers-btn');

        let parsedData = [];
        let map = null;
        let visibleLayers = null;
        let layersByDate = {};
        let tileLayer = null;
        let processedPointsForAI = [];
        let hotzoneCircle = null;

        // --- 地圖高度動態調整 (使用 MutationObserver) ---
        function adjustMapHeight() {
            const leftControls = document.getElementById('left-controls');
            const mapCard = document.getElementById('map-card');
            
            if (leftControls && mapCard) {
                if (window.innerWidth >= 1024) { 
                    const leftHeight = leftControls.offsetHeight;
                    if (leftHeight > 0) {
                        mapCard.style.height = `${leftHeight}px`;
                    }
                } else {
                    mapCard.style.height = '60vh';
                }
            }
            if (map) {
                map.invalidateSize();
            }
        }

        // --- 地圖初始化 ---
        function initMap() {
            if (map) return;
            const cleanTileUrl = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
            const attribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>';
            map = L.map('map').setView([23.9738, 120.982], 8);
            tileLayer = L.tileLayer(cleanTileUrl, { attribution, maxZoom: 19 }).addTo(map);
        }
        
        // --- API 金鑰與事件監聽 ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            adjustMapHeight();
            const savedApiKey = localStorage.getItem('gemini_api_key_trajectory');
            if (savedApiKey) apiKeyInput.value = savedApiKey;

            const leftControls = document.getElementById('left-controls');
            if (leftControls) {
                const observer = new MutationObserver(() => {
                    requestAnimationFrame(adjustMapHeight);
                });
                observer.observe(leftControls, {
                    attributes: true,
                    childList: true,
                    subtree: true,
                    attributeFilter: ['class']
                });
            }
        });

        window.addEventListener('resize', adjustMapHeight);

        saveApiKeyBtn.addEventListener('click', () => {
            const apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                localStorage.setItem('gemini_api_key_trajectory', apiKey);
                statusDiv.textContent = 'API 金鑰已成功儲存！';
            } else {
                localStorage.removeItem('gemini_api_key_trajectory');
                statusDiv.textContent = 'API 金鑰已清除。';
            }
        });
        
        // --- Gemini API 呼叫 ---
        async function callGemini(prompt) {
            let apiKey = localStorage.getItem('gemini_api_key_trajectory') || "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                if (response.status === 401 || response.status === 403) throw new Error(`API 認證失敗 (狀態碼: ${response.status})。請在「AI 功能設定」區塊中，確認您已輸入有效且具備權限的 Google AI API 金鑰。`);
                throw new Error(`API 請求失敗，狀態碼: ${response.status}。`);
            }
            const result = await response.json();
            if (result.candidates && result.candidates.length > 0) return result.candidates[0].content.parts[0].text;
            if (result.promptFeedback && result.promptFeedback.blockReason) throw new Error(`請求被封鎖: ${result.promptFeedback.blockReason}`);
            throw new Error("從 API 收到的回應無效或為空。");
        }

        // --- 日期時間解析器 ---
        function excelSerialDateToJSDate(serial) {
            const utc_days = Math.floor(serial - 25569);
            const utc_value = utc_days * 86400;
            const date_info = new Date(utc_value * 1000);
            const fractional_day = serial - Math.floor(serial) + 0.0000001;
            let total_seconds = Math.floor(86400 * fractional_day);
            const seconds = total_seconds % 60;
            total_seconds -= seconds;
            const hours = Math.floor(total_seconds / (60 * 60));
            const minutes = Math.floor(total_seconds / 60) % 60;
            return new Date(date_info.getFullYear(), date_info.getMonth(), date_info.getDate(), hours, minutes, seconds);
        }

        function parseDateTime(dateStr) {
            if (dateStr === null || dateStr === undefined) return null;
            const dateStrClean = String(dateStr).trim();

            if (!isNaN(dateStrClean) && Number(dateStrClean) > 10000 && dateStrClean.indexOf('-') === -1 && dateStrClean.indexOf('/') === -1) {
                return excelSerialDateToJSDate(Number(dateStrClean));
            }

            const rocRegex = /^(\d{2,3})[\/-]?(\d{1,2})[\/-]?(\d{1,2})/;
            const match = dateStrClean.match(rocRegex);
            if (match && parseInt(match[1], 10) < 200) {
                try {
                    const rocYear = parseInt(match[1], 10);
                    const gregorianYear = rocYear + 1911;
                    const timePart = dateStrClean.substring(match[0].length).trim();
                    const standardDateStr = `${gregorianYear}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')} ${timePart}`;
                    const date = new Date(standardDateStr);
                    if (!isNaN(date.getTime())) return date;
                } catch (e) {
                    console.error("民國年解析失敗:", dateStrClean, e);
                }
            }
            
            const date = new Date(dateStrClean);
            if (!isNaN(date.getTime())) {
                return date;
            }

            console.error("所有日期格式解析失敗:", dateStrClean);
            return null;
        }

        // --- 檔案處理 ---
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            fileNameSpan.textContent = file.name;
            processBtn.disabled = true;
            [columnMappingDiv, actionsCard, aiAnalysisCard, layerControlCard, dashboardCard, dataDisplayCard].forEach(el => {
                if(el) el.classList.add('hidden');
            });
            statusDiv.innerHTML = '<div class="loader mx-auto"></div><span>正在解析檔案...</span>';
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = e.target.result;
                    if (file.name.endsWith('.csv')) {
                        const lines = data.split(/\r\n|\n/).filter(line => line);
                        const headers = lines[0].match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g).map(h => h.replace(/"/g, '').trim());
                        parsedData = lines.slice(1).map(line => {
                            const values = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
                            return headers.reduce((obj, header, i) => {
                                obj[header] = values[i] ? values[i].replace(/"/g, '').trim() : '';
                                return obj;
                            }, {});
                        });
                    } else {
                        const workbook = XLSX.read(data, { type: 'binary' });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        parsedData = XLSX.utils.sheet_to_json(worksheet);
                    }
                    if(parsedData.length > 0) {
                        populateColumnSelectors(Object.keys(parsedData[0]));
                        renderDataTable(parsedData);
                        statusDiv.textContent = '解析完成，請對應欄位後點擊「繪製軌跡」。';
                    } else { throw new Error('檔案為空或格式不符。'); }
                } catch (err) { statusDiv.textContent = `檔案解析失敗: ${err.message}`; }
            };
            reader.onerror = () => statusDiv.textContent = '無法讀取檔案。';
            if (file.name.endsWith('.csv')) { reader.readAsText(file, 'UTF-8'); } 
            else { reader.readAsBinaryString(file); }
        });

        function populateColumnSelectors(headers) {
            [latSelect, lonSelect, timeSelect].forEach(s => s.innerHTML = '');
            headers.forEach(header => {
                const option = `<option value="${header}">${header}</option>`;
                [latSelect, lonSelect, timeSelect].forEach(s => s.innerHTML += option);
            });
            headers.forEach(h => {
                const lower_h = h.toLowerCase();
                if (lower_h.includes('lat') || lower_h.includes('緯度')) latSelect.value = h;
                if (lower_h.includes('lon') || lower_h.includes('lng') || lower_h.includes('經度')) lonSelect.value = h;
                if (lower_h.includes('time') || lower_h.includes('時間')) timeSelect.value = h;
            });
            columnMappingDiv.classList.remove('hidden');
            processBtn.disabled = false;
        }

        function renderDataTable(data) {
            const table = document.createElement('table');
            table.className = 'data-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            const headers = Object.keys(data[0]);
            const headerRow = document.createElement('tr');
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            const dataToShow = data.slice(0, 50);
            dataToShow.forEach(rowData => {
                const row = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = rowData[header];
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
            table.appendChild(thead);
            table.appendChild(tbody);
            
            if (dataTableContainer) {
                dataTableContainer.innerHTML = '';
                dataTableContainer.appendChild(table);
            }
        }

        // --- 軌跡繪製 ---
        processBtn.addEventListener('click', () => {
            if (parsedData.length === 0) {
                statusDiv.textContent = '請先上傳並解析檔案。';
                return;
            }
            statusDiv.innerHTML = '<div class="loader mx-auto"></div><span>正在繪製軌跡...</span>';
            setTimeout(() => {
                try {
                    const latCol = latSelect.value, lonCol = lonSelect.value, timeCol = timeSelect.value;
                    
                    if (visibleLayers) map.removeLayer(visibleLayers);
                    if (hotzoneCircle) map.removeLayer(hotzoneCircle);
                    visibleLayers = L.featureGroup().addTo(map);
                    layersByDate = {};

                    processedPointsForAI = parsedData.map(row => {
                        const lat = parseFloat(row[latCol]);
                        const lon = parseFloat(row[lonCol]);
                        const time = parseDateTime(row[timeCol]);
                        if (isNaN(lat) || isNaN(lon) || !time) return null;
                        return { ...row, lat, lon, time };
                    }).filter(p => p !== null);

                    processedPointsForAI.sort((a, b) => a.time - b.time);
                    if (processedPointsForAI.length === 0) throw new Error('找不到有效的經緯度或時間資料。');

                    const pointsByDate = processedPointsForAI.reduce((acc, point) => {
                        const year = point.time.getFullYear();
                        const month = String(point.time.getMonth() + 1).padStart(2, '0');
                        const day = String(point.time.getDate()).padStart(2, '0');
                        const date = `${year}-${month}-${day}`;
                        if (!acc[date]) acc[date] = [];
                        acc[date].push(point);
                        return acc;
                    }, {});

                    const dates = Object.keys(pointsByDate).sort();
                    const colors = ['#3b82f6', '#ef4444', '#16a34a', '#f97316', '#8b5cf6', '#ec4899', '#0891b2'];
                    const dateColors = {};

                    dates.forEach((date, dateIndex) => {
                        const dailyPoints = pointsByDate[date];
                        const color = colors[dateIndex % colors.length];
                        dateColors[date] = color;
                        layersByDate[date] = L.featureGroup();

                        const latLngs = dailyPoints.map(p => [p.lat, p.lon]);
                        const polyline = L.polyline(latLngs, { color: color, weight: 4, opacity: 0.8 });
                        layersByDate[date].addLayer(polyline);

                        const decorator = L.polylineDecorator(polyline, {
                            patterns: [{ offset: 25, repeat: 50, symbol: L.Symbol.arrowHead({ pixelSize: 12, pathOptions: { fillOpacity: 1, weight: 0, color: color } }) }]
                        });
                        layersByDate[date].addLayer(decorator);

                        dailyPoints.forEach((p, index) => {
                            let markerColor = color;
                            if (index === 0) markerColor = '#16a34a';
                            else if (index === dailyPoints.length - 1) markerColor = '#ef4444';
                            
                            const numberIcon = L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div class="number-marker" style="background-color: ${markerColor};">${index + 1}</div>`,
                                iconSize: [24, 24], iconAnchor: [12, 12]
                            });
                            const marker = L.marker([p.lat, p.lon], { icon: numberIcon });
                            
                            let tooltipContent = '<div style="font-family: sans-serif; color: #111827; max-width: 250px; word-wrap: break-word;">';
                            for (const key in p) {
                                if(!['lat', 'lon', 'time'].includes(key)) tooltipContent += `<strong style="color: #4b5563;">${key}:</strong> ${p[key]}<br>`;
                            }
                            tooltipContent += '</div>';
                            marker.bindTooltip(tooltipContent);
                            layersByDate[date].addLayer(marker);
                        });
                    });

                    updateDashboard(pointsByDate, processedPointsForAI);
                    setupLayerControls(dateColors);
                    updateVisibleLayers();
                    statusDiv.textContent = `成功繪製 ${dates.length} 天的軌跡！`;
                    [actionsCard, aiAnalysisCard, layerControlCard, dashboardCard, dataDisplayCard].forEach(el => {
                        if(el) el.classList.remove('hidden');
                    });
                } catch (err) { statusDiv.textContent = `繪製失敗: ${err.message}`; }
            }, 50);
        });
        
        // --- 輔助函式: 計算距離與群集 ---
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // 地球半徑 (公尺)
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function clusterHotZones(points, radiusInMeters) {
            const clusters = [];
            points.forEach(point => {
                let foundCluster = false;
                for (const cluster of clusters) {
                    const distance = calculateDistance(point.lat, point.lon, cluster.center.lat, cluster.center.lon);
                    if (distance <= radiusInMeters) {
                        cluster.points.push(point);
                        const totalLat = cluster.points.reduce((sum, p) => sum + p.lat, 0);
                        const totalLon = cluster.points.reduce((sum, p) => sum + p.lon, 0);
                        cluster.center = { lat: totalLat / cluster.points.length, lon: totalLon / cluster.points.length };
                        foundCluster = true;
                        break;
                    }
                }
                if (!foundCluster) {
                    clusters.push({
                        center: { lat: point.lat, lon: point.lon },
                        points: [point]
                    });
                }
            });
            return clusters;
        }

        // --- 儀表板更新函式 (已升級熱區分析) ---
        function updateDashboard(pointsByDate, allPoints) {
            hotZoneDisplay.innerHTML = '';
            const CLUSTER_RADIUS_METERS = 50; 

            if (allPoints.length > 1) {
                const clusters = clusterHotZones(allPoints, CLUSTER_RADIUS_METERS);
                clusters.sort((a, b) => b.points.length - a.points.length);
                const hotClusters = clusters.filter(c => c.points.length > 1 && c.points.length === clusters[0].points.length);

                if (hotClusters.length > 0 && clusters[0].points.length > 1) {
                    hotZoneDisplay.innerHTML = `<p class="text-xs text-gray-400 mb-2">聚合半徑: ${CLUSTER_RADIUS_METERS} 公尺</p>`;
                    hotClusters.forEach(cluster => {
                        const centerLat = cluster.center.lat.toFixed(6);
                        const centerLon = cluster.center.lon.toFixed(6);
                        const pointCount = cluster.points.length;
                        
                        const item = document.createElement('div');
                        item.className = 'dashboard-list-item text-sm';
                        item.innerHTML = `<span class="clickable-coord" data-lat="${centerLat}" data-lon="${centerLon}">中心: ${centerLat}, ${centerLon}</span> (共 ${pointCount} 個點)`;
                        item.querySelector('span').addEventListener('click', (e) => {
                            const lat = parseFloat(e.target.dataset.lat);
                            const lon = parseFloat(e.target.dataset.lon);
                            map.flyTo([lat, lon], 16);
                            if (hotzoneCircle) map.removeLayer(hotzoneCircle);
                            hotzoneCircle = L.circle([lat, lon], {
                                radius: CLUSTER_RADIUS_METERS,
                                color: '#f97316',
                                fillColor: '#f97316',
                                fillOpacity: 0.2
                            }).addTo(map);
                        });
                        hotZoneDisplay.appendChild(item);
                    });
                } else {
                    hotZoneDisplay.textContent = '無明顯熱區 (沒有點位聚合)';
                }
            } else {
                hotZoneDisplay.textContent = '資料不足，無法分析熱區';
            }

            dailyStartDisplay.innerHTML = '';
            dailyEndDisplay.innerHTML = '';
            const sortedDates = Object.keys(pointsByDate).sort();

            for (const date of sortedDates) {
                const dailyPoints = pointsByDate[date];
                if(dailyPoints.length === 0) continue;
                const firstPoint = dailyPoints[0];
                const lastPoint = dailyPoints[dailyPoints.length - 1];

                const createListItem = (point) => {
                    const li = document.createElement('div');
                    li.className = 'dashboard-list-item text-sm';
                    li.innerHTML = `
                        <span>${date}:</span>
                        <span class="clickable-coord ml-2" data-lat="${point.lat}" data-lon="${point.lon}">${point.time.toLocaleTimeString('zh-TW')}</span>
                    `;
                    li.querySelector('span.clickable-coord').addEventListener('click', (e) => {
                        map.flyTo([e.target.dataset.lat, e.target.dataset.lon], 16);
                    });
                    return li;
                };
                dailyStartDisplay.appendChild(createListItem(firstPoint));
                dailyEndDisplay.appendChild(createListItem(lastPoint));
            }
        }

        // --- 圖層控制 ---
        function setupLayerControls(dateColors) {
            dateCheckboxesContainer.innerHTML = '';
            const sortedDates = Object.keys(dateColors).sort();
            for (const date of sortedDates) {
                const color = dateColors[date];
                const item = document.createElement('label');
                item.className = 'layer-control-item';
                item.innerHTML = `
                    <input type="checkbox" class="date-checkbox" data-date="${date}" checked>
                    <span class="color-box" style="background-color: ${color}"></span>
                    <span>${date}</span>
                `;
                item.querySelector('input').addEventListener('change', updateVisibleLayers);
                dateCheckboxesContainer.appendChild(item);
            }
        }

        function updateVisibleLayers() {
            visibleLayers.clearLayers();
            const checkboxes = document.querySelectorAll('.date-checkbox');
            let hasVisibleLayer = false;
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    const date = cb.dataset.date;
                    if (layersByDate[date]) {
                        visibleLayers.addLayer(layersByDate[date]);
                        hasVisibleLayer = true;
                    }
                }
            });

            if (hasVisibleLayer) {
                map.fitBounds(visibleLayers.getBounds(), { padding: [50, 50], animate: true });
            }
        }

        toggleAllLayersBtn.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.date-checkbox');
            const isAnyChecked = Array.from(checkboxes).some(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !isAnyChecked);
            updateVisibleLayers();
        });

        // --- 軌跡工具 ---
        routeBtn.addEventListener('click', () => {
            if (processedPointsForAI.length < 2) {
                statusDiv.textContent = '需要至少兩個點位才能規劃路線。';
                return;
            }
            const origin = processedPointsForAI[0];
            const destination = processedPointsForAI[processedPointsForAI.length - 1];
            let waypoints = '';
            if (processedPointsForAI.length > 2) {
                const waypointsData = processedPointsForAI.length > 25 ? 
                    processedPointsForAI.slice(1, -1).filter((_, i) => i % Math.ceil(processedPointsForAI.length / 23) === 0) :
                    processedPointsForAI.slice(1, -1);
                waypoints = waypointsData.map(p => `${p.lat},${p.lon}`).join('|');
            }
            const url = `https://www.google.com/maps/dir/?api=1&origin=${origin.lat},${origin.lon}&destination=${destination.lat},${destination.lon}&waypoints=${waypoints}&travelmode=driving`;
            window.open(url, '_blank');
        });

        recenterMapBtn.addEventListener('click', () => {
            if (visibleLayers && Object.keys(visibleLayers.getLayers()).length > 0) {
                map.fitBounds(visibleLayers.getBounds(), { padding: [50, 50], animate: true });
                statusDiv.textContent = '可見軌跡已置中。';
            } else {
                statusDiv.textContent = '地圖上沒有可見軌跡可供置中。';
            }
        });

        // --- 下載圖檔功能 ---
        downloadMapBtn.addEventListener('click', () => {
            if (!visibleLayers || !visibleLayers.getBounds().isValid()) {
                statusDiv.textContent = '地圖上沒有可見軌跡可供下載。';
                return;
            }

            const originalHTML = downloadMapBtn.innerHTML;
            downloadMapBtn.disabled = true;
            downloadMapBtn.innerHTML = '<div class="loader mx-auto"></div>';
            statusDiv.textContent = '正在準備擷取畫面...';

            const performCapture = async () => {
                try {
                    statusDiv.textContent = '正在擷取圖檔...';
                    const mapElement = document.getElementById('map');
                    const controlsToHide = mapElement.querySelectorAll('.leaflet-control-container');
                    controlsToHide.forEach(c => c.style.visibility = 'hidden');
                    const canvas = await html2canvas(mapElement, { useCORS: true, logging: false });
                    controlsToHide.forEach(c => c.style.visibility = 'visible');
                    const link = document.createElement('a');
                    link.download = 'trajectory_map.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    statusDiv.textContent = '圖檔已開始下載！';
                } catch (err) {
                    statusDiv.textContent = `產生圖檔失敗: ${err.message}`;
                } finally {
                    downloadMapBtn.disabled = false;
                    downloadMapBtn.innerHTML = originalHTML;
                }
            };
            
            map.once('moveend', () => {
                setTimeout(performCapture, 500); 
            });

            map.fitBounds(visibleLayers.getBounds(), { padding: [50, 50] });
        });

        // --- AI 分析功能 ---
        aiSubmitBtn.addEventListener('click', async () => {
            const originalHTML = aiSubmitBtn.innerHTML;
            aiSubmitBtn.disabled = true;
            aiSubmitBtn.innerHTML = '<div class="loader mx-auto"></div>';
            aiOutput.value = "AI 正在分析中，請稍候...";
            try {
                if (processedPointsForAI.length === 0) throw new Error("沒有可供分析的軌跡資料。");
                const userPrompt = customPromptInput.value.trim();
                if (!userPrompt) throw new Error("請輸入您的分析指令。");

                const dataString = processedPointsForAI.map(p => JSON.stringify(p)).join('\n');
                const prompt = `你是一位專業的數據分析師與調查員。請根據以下提供的 JSON 格式車輛軌跡數據，用繁體中文回答「使用者的問題」。你的回答必須完全基於提供的數據。

---
【軌跡數據】:
${dataString}
---
【使用者的問題】:
${userPrompt}
---
【你的分析】:`;
                const result = await callGemini(prompt);
                aiOutput.value = result;
            } catch (err) {
                aiOutput.value = `分析失敗: ${err.message}`;
            } finally {
                aiSubmitBtn.disabled = false;
                aiSubmitBtn.innerHTML = originalHTML;
            }
        });

    </script>
</body>
</html>
