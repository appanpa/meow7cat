<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¡Œè»Šè»Œè·¡åœç•™åˆ†æå·¥å…· v13 (é™„ä½¿ç”¨èªªæ˜)</title>
    
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet.markercluster CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    
    <!-- SheetJS (xlsx.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- FileSaver.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>

    <style>
        /* CSS is the same as previous versions */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #f4f7f9; color: #333; line-height: 1.6; margin: 0; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background-color: #fff; padding: 25px 30px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); }
        h1 { color: #2c3e50; text-align: center; border-bottom: 2px solid #e0e0e0; padding-bottom: 15px; margin-top: 0; }
        h1 small { display: block; font-size: 0.5em; color: #3498db; font-weight: 500; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; align-items: end; padding: 20px; background-color: #f8f9fa; border-radius: 6px; margin-bottom: 25px; }
        .control-group { display: flex; flex-direction: column; }
        label { font-weight: 600; margin-bottom: 5px; font-size: 0.9em; color: #555; }
        input[type="file"], input[type="number"] { border: 1px solid #ccc; padding: 8px; border-radius: 4px; width: 100%; box-sizing: border-box; }
        button { padding: 10px 20px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; transition: background-color 0.3s ease; height: 40px; }
        button:disabled { background-color: #a9cce3; cursor: not-allowed; }
        #status { margin-top: 20px; padding: 15px; border-radius: 4px; background-color: #e9ecef; border-left: 5px solid #6c757d; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #map { height: 500px; width: 100%; margin-top: 25px; border-radius: 6px; border: 1px solid #ccc; }
        .results-container { margin-top: 25px; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 10px 12px; text-align: left; white-space: nowrap; }
        th.sortable { cursor: pointer; position: relative; background-color: #34495e; color: white; }
        .sort-indicator { margin-left: 8px; }
        td a { color: #3498db; text-decoration: none; }
        #exportBtn { display: none; margin-top: 20px; background-color: #27ae60; }

        /* --- ã€NEWã€‘ä½¿ç”¨èªªæ˜æ¨£å¼ --- */
        .instructions {
            margin-bottom: 25px;
            background-color: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px 20px;
        }
        .instructions summary {
            font-weight: 600;
            cursor: pointer;
            font-size: 1.1em;
            color: #2c3e50;
        }
        .instructions .content {
            margin-top: 15px;
            padding-left: 10px;
            border-left: 3px solid #3498db;
            line-height: 1.7;
        }
        .instructions h4 {
            margin-top: 10px;
            margin-bottom: 5px;
            color: #34495e;
        }
        .instructions code {
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
        .instructions ul, .instructions ol {
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>è¡Œè»Šè»Œè·¡åœç•™åˆ†æå·¥å…·</h1>
        
        <!-- --- ã€NEWã€‘ä½¿ç”¨èªªæ˜å€å¡Š --- -->
        <details class="instructions">
            <summary>ğŸ“– ä½¿ç”¨èªªæ˜ (ä¸‰åˆ†é˜ä¸Šæ‰‹ï¼Œé»æ“Šå±•é–‹)</summary>
            <div class="content">
                <h4>1. æº–å‚™è³‡æ–™</h4>
                <p>
                    æº–å‚™å¥½æ‚¨çš„ Excel æª”æ¡ˆï¼Œä¸¦ç¢ºèªæª”æ¡ˆä¸­åŒ…å«ä»¥ä¸‹å¿…è¦æ¬„ä½ï¼š<br>
                    <code>#</code>, <code>æ—¥æœŸ/æ™‚é–“</code>, <code>åœ°å€</code>, <code>Km/h</code>, <code>ç·¯åº¦</code>, <code>ç¶“åº¦</code>
                </p>

                <h4>2. ä¸Šå‚³èˆ‡è¨­å®š</h4>
                <ol>
                    <li><strong>é¸æ“‡æª”æ¡ˆ</strong>ï¼šé»æ“ŠæŒ‰éˆ•ï¼Œé¸æ“‡æ‚¨çš„ Excel æª”ã€‚</li>
                    <li><strong>è¨­å®šåˆ†ç¾¤è·é›¢</strong>ï¼šè¼¸å…¥æ‚¨èªç‚ºå¤šè¿‘çš„è·é›¢ç®—æ˜¯åŒä¸€å€‹åœ°é» (é è¨­ 20 å…¬å°º)ã€‚</li>
                    <li><strong>è¨­å®šæœ€å°åœç•™ç§’æ•¸</strong>ï¼šè¼¸å…¥æ‚¨èªç‚ºåœå¤šä¹…æ‰ç®—æœ‰æ„ç¾© (é è¨­ 10 ç§’)ã€‚</li>
                    <li><strong>è¨­å®šæœ€å¤§æ™‚é–“é–“éš”</strong>ï¼šå¦‚æœå…©ç­†åœè»Šç´€éŒ„ä¸­é–“éš”çš„æ™‚é–“å¤ªé•·ï¼ˆä¾‹å¦‚è¶…é10åˆ†é˜ï¼‰ï¼Œå°±ç®—åœ°é»ä¸€æ¨¡ä¸€æ¨£ï¼Œä¹Ÿè¦æŠŠå®ƒå€‘ç•¶æˆæ˜¯å…©æ¬¡ä¸åŒçš„äº‹ä»¶ã€‚<strong>ç›®çš„ï¼Œå°±æ˜¯è¦é˜²æ­¢é›»è…¦çŠ¯ä¸‹ã€ŒæŠŠæ—©ä¸Šçš„åœè»Šå’Œä¸‹åˆçš„åœè»Šï¼Œèª¤æœƒæˆä¸€æ¬¡è¶…é•·çš„é€£çºŒåœè»Šã€é€™ç¨®éŒ¯èª¤</strong>ã€‚</li>
                </ol>

                <h4>3. é»æ“Šåˆ†æ</h4>
                <p>
                    é»æ“Šã€Œé–‹å§‹åˆ†æã€æŒ‰éˆ•ï¼Œç¨‹å¼æœƒè‡ªå‹•å®Œæˆæ‰€æœ‰å·¥ä½œï¼Œä¸¦é¡¯ç¤ºè™•ç†é€²åº¦ã€‚
                </p>

                <h4>4. æª¢è¦–èˆ‡åŒ¯å‡ºçµæœ</h4>
                <p>åˆ†æå®Œæˆå¾Œï¼Œæ‚¨æœƒå¾—åˆ°ï¼š</p>
                <ul>
                    <li><strong>ä¸€å€‹äº’å‹•åœ°åœ–</strong>ï¼šæ‚¨å¯ä»¥ç¸®æ”¾ã€æ‹–æ›³åœ°åœ–ï¼Œé»æ“Šåœ°åœ–ä¸Šçš„æ³¡æ³¡æŸ¥çœ‹åœç•™æ‘˜è¦ã€‚å¯†é›†çš„é»æœƒè‡ªå‹•èšåˆæˆæ•¸å­—ï¼Œé»æ“Šå¯æ”¾å¤§ã€‚</li>
                    <li><strong>ä¸€å€‹è©³ç´°è¡¨æ ¼</strong>ï¼šä¸‹æ–¹åˆ—å‡ºæ‰€æœ‰åœç•™äº‹ä»¶çš„è©³ç´°è³‡æ–™ã€‚æ‚¨å¯ä»¥é»æ“Šè¡¨é ­ (å¦‚ã€Œåœç•™æ™‚é–“ã€) ä¾†æ’åºçµæœã€‚</li>
                    <li><strong>ä¸€ä»½å¯åŒ¯å‡ºçš„ CSV å ±å‘Š</strong>ï¼šé»æ“Šã€ŒåŒ¯å‡ºçµæœç‚º CSVã€æŒ‰éˆ•ï¼Œå³å¯ä¸‹è¼‰å®Œæ•´çš„åˆ†æå ±å‘Šã€‚å ±å‘Šä¸­çš„æ¯ä¸€è¡Œéƒ½ä»£è¡¨ä¸€æ¬¡ç¨ç«‹ä¸”é€£çºŒçš„åœç•™äº‹ä»¶ã€‚</li>
                </ul>
            </div>
        </details>
        
        <div class="controls">
            <div class="control-group"><label for="fileInput">1. é¸æ“‡ Excel æª”æ¡ˆ</label><input type="file" id="fileInput" accept=".xlsx, .xls, .csv"></div>
            <div class="control-group"><label for="clusterDistance">2. åˆ†ç¾¤è·é›¢ (å…¬å°º)</label><input type="number" id="clusterDistance" value="20" min="1"></div>
            <div class="control-group"><label for="minDuration">3. æœ€å°åœç•™ç§’æ•¸</label><input type="number" id="minDuration" value="10" min="1"></div>
            <div class="control-group"><label for="maxTimeGap">4. æœ€å¤§æ™‚é–“é–“éš” (ç§’)</label><input type="number" id="maxTimeGap" value="600" min="1" title="é€£çºŒéœæ­¢é»è‹¥é–“éš”è¶…éæ­¤ç§’æ•¸ï¼Œè¦–ç‚ºä¸åŒåœç•™äº‹ä»¶"></div>
            <button id="processBtn">5. é–‹å§‹åˆ†æ</button>
        </div>
        <div id="status">è«‹é¸æ“‡æª”æ¡ˆä¸¦è¨­å®šåƒæ•¸ã€‚æ‚¨çš„æª”æ¡ˆä¸æœƒè¢«ä¸Šå‚³ã€‚</div>
        <div class="loader" id="loader"></div>
        <div id="map"></div>
        <div class="results-container">
            <button id="exportBtn">åŒ¯å‡ºçµæœç‚º CSV</button>
            <div id="resultsTable"></div>
            <button id="loadMoreBtn" style="display:none; width:100%; margin-top:15px; padding:10px;">è¼‰å…¥æ›´å¤š</button>
        </div>
    </div>

    <script>
        // JavaScript ç¨‹å¼ç¢¼éƒ¨åˆ†èˆ‡ v12 å®Œå…¨ç›¸åŒï¼Œæ­¤è™•çœç•¥ä»¥ä¿æŒç°¡æ½”
        // The JavaScript logic is identical to v12 and remains unchanged.
        // ... (v12 çš„æ‰€æœ‰ JavaScript ç¨‹å¼ç¢¼)
        // ã€IMPROVEMENTã€‘ä½¿ç”¨å¸¸æ•¸ç®¡ç†æ¬„ä½åç¨±ï¼Œé¿å…é­”æ³•å­—ä¸²
        const COLUMNS = {
            ID: '#',
            TIMESTAMP: 'æ—¥æœŸ/æ™‚é–“',
            ADDRESS: 'åœ°å€',
            STATUS: 'ç‹€æ…‹',
            SPEED: 'Km/h',
            LATITUDE: 'ç·¯åº¦',
            LONGITUDE: 'ç¶“åº¦'
        };

        // DOM Elements
        const processBtn = document.getElementById('processBtn');
        const fileInput = document.getElementById('fileInput');
        const minDurationInput = document.getElementById('minDuration');
        const clusterDistanceInput = document.getElementById('clusterDistance');
        const maxTimeGapInput = document.getElementById('maxTimeGap');
        const statusDiv = document.getElementById('status');
        const loader = document.getElementById('loader');
        const resultsTableDiv = document.getElementById('resultsTable');
        const exportBtn = document.getElementById('exportBtn');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        
        // State
        let allResultsData = [];
        let displayedRows = 0;
        const ROWS_PER_PAGE = 100;
        let currentSortColumn = 'æœ€æ—©æ™‚é–“', currentSortDirection = 'asc';
        let map, markerClusterGroup;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            map = L.map('map').setView([23.97, 120.98], 8);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap'
            }).addTo(map);
            markerClusterGroup = L.markerClusterGroup();
            map.addLayer(markerClusterGroup);
            exportBtn.addEventListener('click', exportToCsv);
        });
        
        processBtn.addEventListener('click', handleFile);
        loadMoreBtn.addEventListener('click', () => renderTable(false));

        // --- ASYNC PROCESSING LOGIC ---
        function runAsyncTask(taskGenerator) { const task = taskGenerator(); return new Promise((resolve, reject) => { function step() { try { const { value, done } = task.next(); if (done) { resolve(value); } else { requestAnimationFrame(step); } } catch (e) { reject(e); } } step(); }); }
        async function handleFile() { const file = fileInput.files[0]; if (!file) { logStatus('éŒ¯èª¤ï¼šè«‹å…ˆé¸æ“‡ä¸€å€‹æª”æ¡ˆï¼', true); return; } resetUI(); logStatus(`æ­¥é©Ÿ 1: æ­£åœ¨è®€å–æª”æ¡ˆ...`); try { const fileBuffer = await file.arrayBuffer(); const workbook = XLSX.read(fileBuffer, { type: 'array', cellDates: true }); const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]); await processData(jsonData); } catch (err) { handleError(`æª”æ¡ˆè™•ç†å¤±æ•—: ${err.message}`); } }
        async function processData(data) { try { const requiredCols = [COLUMNS.ID, COLUMNS.TIMESTAMP, COLUMNS.ADDRESS, COLUMNS.SPEED, COLUMNS.LATITUDE, COLUMNS.LONGITUDE]; if (!checkRequiredColumns(data, requiredCols)) return; const cleanedData = await runAsyncTask(function*() { logStatus('æ­¥é©Ÿ 2.1: æ¸…ç†è³‡æ–™...'); yield; return cleanAndTransformData(data); }); const filteredData = await runAsyncTask(function*() { const result = []; const total = cleanedData.length; for (let i = 0; i < total; i++) { if (i % 2000 === 0) { logStatus(`æ­¥é©Ÿ 3: ç¯©é¸ä¸­... (${i}/${total})`); yield; } const row = cleanedData[i]; if (row[COLUMNS.ADDRESS] !== 'GPS æœªå®šä½' && row[COLUMNS.SPEED] >= 0 && row[COLUMNS.SPEED] <= 3) { result.push(row); } } logStatus(`-> ç¯©é¸å¾Œå‰©é¤˜ ${result.length} ç­†è³‡æ–™ã€‚`); return result; }); if (filteredData.length === 0) { logStatus('ç¯©é¸å¾Œç„¡è³‡æ–™å¯åˆ†æã€‚'); stopLoading(); return; } filteredData.sort((a, b) => a[COLUMNS.TIMESTAMP] - b[COLUMNS.TIMESTAMP]); const aggregatedEvents = await runAsyncTask(function*() { logStatus('æ­¥é©Ÿ 4: ç©ºé–“èˆ‡æ™‚é–“åˆ†ç¾¤...'); const clusterDistance = parseFloat(clusterDistanceInput.value); const maxTimeGap = parseInt(maxTimeGapInput.value, 10); const events = clusterDataByDistance(filteredData, clusterDistance, maxTimeGap); const result = events.map(eventGroup => { const first = eventGroup[0], last = eventGroup[eventGroup.length - 1]; const avgCoords = calculateAverageCoords(eventGroup); return { 'åœ°å€': first[COLUMNS.ADDRESS], 'æœ€æ—©æ™‚é–“': first[COLUMNS.TIMESTAMP], 'æœ€æ™šæ™‚é–“': last[COLUMNS.TIMESTAMP], 'é–‹å§‹åºè™Ÿ': first[COLUMNS.ID], 'çµæŸåºè™Ÿ': last[COLUMNS.ID], 'åœç•™ç§’æ•¸': (last[COLUMNS.TIMESTAMP] - first[COLUMNS.TIMESTAMP]) / 1000, 'ç·¯åº¦': avgCoords.lat, 'ç¶“åº¦': avgCoords.lon }; }); logStatus(`-> è¨ˆç®—å‡º ${result.length} å€‹åœç•™äº‹ä»¶ã€‚`); yield; return result; }); const minDuration = parseInt(minDurationInput.value, 10); logStatus(`æ­¥é©Ÿ 5: éæ¿¾åœç•™æ™‚é–“å°æ–¼ ${minDuration} ç§’çš„äº‹ä»¶...`); allResultsData = aggregatedEvents.filter(event => event.åœç•™ç§’æ•¸ >= minDuration); logStatus(`-> éæ¿¾å¾Œï¼Œå‰©é¤˜ ${allResultsData.length} å€‹æœ‰æ•ˆçš„åœç•™äº‹ä»¶ã€‚`); sortTable('æœ€æ—©æ™‚é–“', true); } catch (err) { handleError(`è³‡æ–™è™•ç†éŒ¯èª¤: ${err.message}`); } }
        
        // --- DISPLAY & UTILITY LOGIC ---
        function displayResults() { renderTable(true); renderMap(); stopLoading(); }
        async function renderMap() { markerClusterGroup.clearLayers(); if (allResultsData.length === 0) { map.setView([23.97, 120.98], 8); return; } await runAsyncTask(function*() { const markers = []; const total = allResultsData.length; const durations = allResultsData.map(d => d.åœç•™ç§’æ•¸); const minDuration = Math.min(...durations), maxDuration = Math.max(...durations); for(let i = 0; i < total; i++) { if (i % 200 === 0) { logStatus(`æ­¥é©Ÿ 6: æ¸²æŸ“åœ°åœ–æ¨™è¨˜... (${i}/${total})`); yield; } const row = allResultsData[i]; const radius = calculateRadius(row.åœç•™ç§’æ•¸, minDuration, maxDuration); const marker = L.circleMarker([row.ç·¯åº¦, row.ç¶“åº¦], { radius, fillColor: "#3498db", color: "#2c3e50", weight: 1, fillOpacity: 0.6 }); marker.bindPopup(`<b>åœ°å€:</b> ${row.åœ°å€}<br><b>åœç•™æ™‚é–“:</b> ${formatSeconds(row.åœç•™ç§’æ•¸)}`); markers.push(marker); } markerClusterGroup.addLayers(markers); if (markers.length > 0) { map.fitBounds(markerClusterGroup.getBounds(), { padding: [50, 50] }); } logStatus(`åˆ†æå®Œæˆï¼å…±æ‰¾åˆ° ${total} å€‹æœ‰æ•ˆåœç•™äº‹ä»¶ã€‚`); }); }
        function renderTable(reset = false) { if (reset) { displayedRows = 0; resultsTableDiv.innerHTML = ''; } const dataToRender = allResultsData.slice(0, displayedRows + ROWS_PER_PAGE); if (dataToRender.length === 0) { resultsTableDiv.innerHTML = '<p>æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„åœç•™äº‹ä»¶ã€‚</p>'; loadMoreBtn.style.display = 'none'; return; } let tableHTML = ''; if (reset) { const headers = [ { key: 'é–‹å§‹åºè™Ÿ', text: 'é–‹å§‹åºè™Ÿ' }, { key: 'çµæŸåºè™Ÿ', text: 'çµæŸåºè™Ÿ' }, { key: 'åœ°å€', text: 'åœ°å€' }, { key: 'ç·¯åº¦', text: 'åº§æ¨™ (åœ°åœ–)' }, { key: 'æœ€æ—©æ™‚é–“', text: 'æœ€æ—©æ™‚é–“' }, { key: 'æœ€æ™šæ™‚é–“', text: 'æœ€æ™šæ™‚é–“' }, { key: 'åœç•™ç§’æ•¸', text: 'åœç•™æ™‚é–“' }, ]; tableHTML += '<table><thead><tr>'; headers.forEach(h => { const sortClass = h.key === currentSortColumn ? `sorted-${currentSortDirection}` : ''; const indicator = h.key === currentSortColumn ? (currentSortDirection === 'asc' ? 'â–²' : 'â–¼') : 'â†•'; tableHTML += `<th class="sortable ${sortClass}" data-sort-key="${h.key}">${h.text} <span class="sort-indicator">${indicator}</span></th>`; }); tableHTML += '</tr></thead><tbody></tbody></table>'; resultsTableDiv.innerHTML = tableHTML; document.querySelectorAll('th.sortable').forEach(th => { th.addEventListener('click', () => sortTable(th.dataset.sortKey)); }); } const tableBody = resultsTableDiv.querySelector('tbody'); let rowsHTML = ''; allResultsData.slice(displayedRows, displayedRows + ROWS_PER_PAGE).forEach(row => { const gmapsUrl = `https://www.google.com/maps?q=${row.ç·¯åº¦},${row.ç¶“åº¦}`; rowsHTML += `<tr><td>${row.é–‹å§‹åºè™Ÿ}</td><td>${row.çµæŸåºè™Ÿ}</td><td>${row.åœ°å€}</td><td><a href="${gmapsUrl}" target="_blank">${row.ç·¯åº¦}, ${row.ç¶“åº¦}</a></td><td>${formatDate(row.æœ€æ—©æ™‚é–“)}</td><td>${formatDate(row.æœ€æ™šæ™‚é–“)}</td><td>${formatSeconds(row.åœç•™ç§’æ•¸)}</td></tr>`; }); tableBody.innerHTML += rowsHTML; displayedRows = tableBody.rows.length; if (displayedRows < allResultsData.length) { loadMoreBtn.style.display = 'block'; } else { loadMoreBtn.style.display = 'none'; } exportBtn.style.display = 'inline-block'; }
        function sortTable(sortKey) { currentSortDirection = (currentSortColumn === sortKey && currentSortDirection === 'asc') ? 'desc' : 'asc'; currentSortColumn = sortKey; allResultsData.sort((a, b) => { const valA = a[sortKey], valB = b[sortKey]; if (valA > valB) return currentSortDirection === 'asc' ? 1 : -1; if (valA < valB) return currentSortDirection === 'asc' ? -1 : 1; return 0; }); displayResults(); }
        function calculateRadius(duration, min, max) { const minR = 6, maxR = 40; if (max <= min) return minR; const scale = (duration - min) / (max - min); return minR + scale * (maxR - minR); }
        function resetUI() { processBtn.disabled = true; loader.style.display = 'block'; resultsTableDiv.innerHTML = ''; exportBtn.style.display = 'none'; loadMoreBtn.style.display = 'none'; allResultsData = []; displayedRows = 0; markerClusterGroup.clearLayers(); }
        function stopLoading() { loader.style.display = 'none'; processBtn.disabled = false; }
        function handleError(message) { logStatus(message, true); stopLoading(); }
        function logStatus(message, isError = false) { statusDiv.textContent = message; statusDiv.style.borderColor = isError ? '#c0392b' : '#6c757d'; }
        function checkRequiredColumns(data, cols) { if(data.length > 0){ const missing = cols.filter(c => !data[0].hasOwnProperty(c)); if (missing.length > 0) { handleError(`éŒ¯èª¤ï¼šExcel ç¼ºå°‘æ¬„ä½: ${missing.join(', ')}`); return false; } } return true; }
        function cleanAndTransformData(data) { return data.map(row => ({ [COLUMNS.ID]: Number(row[COLUMNS.ID]), [COLUMNS.TIMESTAMP]: row[COLUMNS.TIMESTAMP] instanceof Date ? row[COLUMNS.TIMESTAMP] : new Date(row[COLUMNS.TIMESTAMP]), [COLUMNS.ADDRESS]: String(row[COLUMNS.ADDRESS] || '').trim(), [COLUMNS.STATUS]: String(row[COLUMNS.STATUS] || '').trim(), [COLUMNS.SPEED]: Number(row[COLUMNS.SPEED]), [COLUMNS.LATITUDE]: parseFloat(row[COLUMNS.LATITUDE]), [COLUMNS.LONGITUDE]: parseFloat(row[COLUMNS.LONGITUDE]) })).filter(r => !Object.values(r).some(v => v === null || (typeof v === 'number' && isNaN(v)) || (v instanceof Date && isNaN(v.getTime())))); }
        function haversineDistance(lat1, lon1, lat2, lon2) { const R = 6371000; const toRad = (v) => (v * Math.PI) / 180; const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1); const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2; return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); }
        function calculateAverageCoords(points) { const count = points.length; if (count === 0) return { lat: 0, lon: 0 }; const sum = points.reduce((acc, p) => ({ lat: acc.lat + p[COLUMNS.LATITUDE], lon: acc.lon + p[COLUMNS.LONGITUDE] }), { lat: 0, lon: 0 }); return { lat: parseFloat((sum.lat / count).toFixed(6)), lon: parseFloat((sum.lon / count).toFixed(6)) }; }
        
        // ã€CORE ALGORITHM FIXã€‘ä¿®æ­£åˆ†ç¾¤æ¼”ç®—æ³•ï¼ŒåŒæ™‚è€ƒæ…®ç©ºé–“è·é›¢å’Œæ™‚é–“é–“éš”
        function clusterDataByDistance(data, distanceThreshold, maxTimeGapInSeconds) {
            if (data.length === 0) return [];
            let clusters = [];
            let currentCluster = [data[0]];

            for (let i = 1; i < data.length; i++) {
                const prevPoint = data[i - 1];
                const currentPoint = data[i];

                const distance = haversineDistance(prevPoint[COLUMNS.LATITUDE], prevPoint[COLUMNS.LONGITUDE], currentPoint[COLUMNS.LATITUDE], currentPoint[COLUMNS.LONGITUDE]);
                const timeGap = (currentPoint[COLUMNS.TIMESTAMP] - prevPoint[COLUMNS.TIMESTAMP]) / 1000;

                // å¿…é ˆåŒæ™‚æ»¿è¶³ã€Œè·é›¢å¤ è¿‘ã€å’Œã€Œæ™‚é–“é€£çºŒã€ï¼Œæ‰ç®—æ˜¯åŒä¸€å€‹åœç•™äº‹ä»¶
                if (distance <= distanceThreshold && timeGap <= maxTimeGapInSeconds) {
                    currentCluster.push(currentPoint);
                } else {
                    clusters.push(currentCluster);
                    currentCluster = [currentPoint];
                }
            }
            clusters.push(currentCluster); // Don't forget the last cluster
            return clusters;
        }

        function formatDate(date) { return date.toLocaleString('sv-SE').slice(0, 19); }
        function formatSeconds(s) { const h = Math.floor(s / 3600); const m = Math.floor((s % 3600) / 60); return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(Math.floor(s % 60)).padStart(2, '0')}`; }
        
        function exportToCsv() {
            if (allResultsData.length === 0) { alert("æ²’æœ‰å¯åŒ¯å‡ºçš„è³‡æ–™ã€‚"); return; }
            logStatus("æ­£åœ¨ç”Ÿæˆ CSV æª”æ¡ˆ...");
            try {
                const headers = ['é–‹å§‹åºè™Ÿ', 'çµæŸåºè™Ÿ', 'åœ°å€', 'ç·¯åº¦', 'ç¶“åº¦', 'æœ€æ—©æ™‚é–“', 'æœ€æ™šæ™‚é–“', 'åœç•™æ™‚é–“'];
                let csvContent = headers.join(',') + '\r\n';
                allResultsData.forEach(row => {
                    const address = `"${String(row['åœ°å€']).replace(/"/g, '""')}"`;
                    const values = [ row['é–‹å§‹åºè™Ÿ'], row['çµæŸåºè™Ÿ'], address, row['ç·¯åº¦'], row['ç¶“åº¦'], formatDate(row['æœ€æ—©æ™‚é–“']), formatDate(row['æœ€æ™šæ™‚é–“']), formatSeconds(row['åœç•™ç§’æ•¸']) ];
                    csvContent += values.join(',') + '\r\n';
                });
                const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
                saveAs(blob, 'spatial_stay_analysis_v13.csv');
                logStatus("CSV æª”æ¡ˆå·²é–‹å§‹ä¸‹è¼‰ã€‚");
            } catch (error) {
                console.error("åŒ¯å‡º CSV æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
                handleError("åŒ¯å‡º CSV æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè©³æƒ…è«‹æŸ¥çœ‹ç€è¦½å™¨æ§åˆ¶å°ã€‚");
            }
        }
    </script>
</body>
</html>